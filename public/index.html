<!DOCTYPE html>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Blockdown</title>
</head>
<body>

<!--START_CONTENT-->
<h1>Blockdown</h1>
<p>A Markdown-like syntax that supports defining blocks of text.</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#why">Why?</a></li>
<li><a href="#how-it-works">How it Works</a></li>
<li><a href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a href="#multi-line-metadata">Multi-Line Metadata</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#license">License</a></li>
</ul>
<h2>Introduction</h2>
<p>If you are using Markdown with Front Matter, your existing Markdown files are probably already valid Blockdown! ðŸŽ‰</p>
<p>Blockdown does not have opinions about which flavor of Markdown you should use, or which plugins you should support.</p>
<p>Instead, it defines text blocks in such a way that <em>you</em> can decide what to do with them.</p>
<h2>Why?</h2>
<p>A typical Markdown blog post, using Front Matter, might look like this:</p>
<pre><code>---
title: My Post
---

Some exciting words.
</code></pre>
<p>Suppose that you want to include a graph in the middle, using a library like <a href="https://mermaidjs.github.io/">mermaid</a>?</p>
<p>You might be tempted to write something like:</p>
<pre><code>---
title: My Post
---

Some exciting words.

&#x3C;div class="mermaid" data-size="large">
    pie title NETFLIX
        "Time spent looking for movie" : 90
        "Time spent watching it" : 10
&#x3C;/div>

More words.
</code></pre>
<p>Then when you convert the Markdown file to HTML you would look for elements with the CSS <code>.mermaid</code> selector, grab the text, generate a chart, then plug it back in to your HTML.</p>
<p>Sounds doable but... if only there was a better way... ðŸ¤”</p>
<h2>How it Works</h2>
<p>With Blockdown, you define each block of text explicitly, using a delimiter that's easy for humans and computers alike to read:</p>
<ul>
<li><code>---!name</code> The delimiter <strong>must</strong> have a name, which is usually the content type, e.g. <code>mermaid</code>.</li>
<li><code>---!name#id</code> It can also include an identifier, if you need to identify a unique block.</li>
<li><code>---!name[metadata]</code> It can also include metadata, for things like display settings.</li>
<li><code>---!name#id[metadata]</code> Of course, it can include an identifier <em>and</em> metadata.</li>
</ul>
<blockquote>
<p>Note: The metadata is enclosed in square brackets, but the exact syntax of the metadata is <strong>not</strong> specified by Blockdown. Blockdown syntax <em><strong>does not care</strong></em>â€“it leaves metadata interpretation up to you.</p>
</blockquote>
<p>Our earlier example, written in fully explicit format, would be:</p>
<pre><code>---!yaml
title: My Post

---!md

Some exciting words.

---!mermaid[size=large]

pie title NETFLIX
    "Time spent looking for movie" : 90
    "Time spent watching it" : 10

---!md

More words.
</code></pre>
<p>Blockdown syntax doesn't care what the contents are, it only cares about separating the text contents into blocks, and leaves interpreting those blocks up to you.</p>
<p>Each block in a Blockdown document contains the following possible properties:</p>
<ul>
<li><code>name</code> <em>(String, required)</em> The name of the block, e.g. for <code>---!yaml</code> the <code>name</code> would be <code>yaml</code>.</li>
<li><code>id</code> <em>(String, optional)</em> The optional identifier of the block, e.g. for <code>---!yaml#abc</code> the <code>id</code> would be <code>abc</code>.</li>
<li><code>metadata</code> <em>(String, optional)</em> The optional metadata string of whatever is between the square brackets, e.g. for <code>---!yaml#abc[foo]</code> or <code>---!yaml[foo]</code> the <code>metadata</code> would be <code>foo</code>.</li>
<li><code>content</code> <em>(String, optional)</em> Any characters following the block delimiter, up to the next block delimiter or the end of the file.</li>
</ul>
<h2>Backwards Compatibility</h2>
<p>For backwards compatibility with Markdown + <a href="https://jekyllrb.com/docs/front-matter/">Front Matter</a> documents, if the very first line is <code>---</code> then the following block is interpreted as Front Matter, up to the next Blockdown delimiter or <code>---</code> separator.</p>
<p>If the <code>---</code> separator is used (instead of a Blockdown delimiter), the following block is treated as Markdown.</p>
<p>So our earlier example could simply be:</p>
<pre><code>---
title: My Post
---

Some exciting words.

---!mermaid[size=large]

pie title NETFLIX
    "Time spent looking for movie" : 90
    "Time spent watching it" : 10

---!md

More words.
</code></pre>
<h2>Multi-Line Metadata</h2>
<p>You may find that single-line metadata gets cumbersome with large metadata sets.</p>
<p>To use multi-line metadata, you end the delimiter with <code>[</code> (the left square bracket), and close the metadata section with a line containing only the <code>]</code> character (right square bracket).</p>
<p>For example:</p>
<pre><code>---!mermaid[
  size=large
  color=red
]

pie title NETFLIX
	"Time spent looking for movie" : 90
	"Time spent watching it" : 10

---!md

More words.
</code></pre>
<blockquote>
<p>Note: the indentation of the metadata here is optional.</p>
</blockquote>
<h2>Implementation</h2>
<p>This project ships with a JavaScript implementation.</p>
<p>Simply import the <code>parse</code> function and pass it the string:</p>
<pre><code class="language-js">import { readFileSync } from 'fs';
import { parse } from '@saibotsivad/blockdown';

const blockdown = parse(readFileSync('./test/many-chunks.md', 'utf8'));
console.log(blockdown.blocks[3].metadata); // => 'fizz3'
</code></pre>
<h3>API: <code>parse(&#x3C;String>): Object&#x3C;blocks: Array, warnings: Array></code></h3>
<p>This implementation has a very simple API, you simply call the <code>parse</code> function with the string you want parsed.</p>
<p>The returned object contains two potential properties:</p>
<h4><code>blocks: Array&#x3C;Object></code></h4>
<p>The <code>blocks</code> property is an array of all parsed Blockdown blocks, it
contains the following properties:</p>
<ul>
<li><code>name</code> (<code>String</code>, optional) - The name of the block, e.g. for <code>---!yaml</code> this property would be <code>yaml</code>.</li>
<li><code>id</code> (<code>String</code>, optional) - The <code>id</code> of the block, e.g. for <code>---!yaml#part1</code> this property would be <code>part1</code>.</li>
<li><code>metadata</code> (<code>String</code>, optional) - The metadata exactly as represented in the Blockdown block, e.g. without metadata type parsing or de-indentation on multi-line metadata.</li>
<li><code>content</code> (<code>String</code>, optional) - The content between block delimiters.</li>
</ul>
<h3><code>warnings: Array&#x3C;Object></code></h3>
<p>The <code>warnings</code> property is an array of all recoverable parser errors encountered. The array will always exist, but if there were no errors it will be empty.</p>
<p>It contains the following properties:</p>
<ul>
<li><code>index</code> (<code>Integer</code>) - The zero-index line number where the error was first detected.</li>
<li><code>code</code> (<code>String</code>) - The meant-for-machines name of the error type. (As of <code>1.1.0</code>, only <code>UNPARSEABLE_MARKER</code> is used.)</li>
<li><code>line</code> (<code>String</code>) - The text found at the line where the error was first detected.</li>
</ul>
<h2>License</h2>
<p>The project code and all specs are published under the <a href="http://veryopenlicense.com/">Very Open License</a>.</p>
<!--END_CONTENT-->

</body>
</html>
